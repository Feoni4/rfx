#pragma once
#include "pktq.h"
#include "evq.h"
#include "rfx_api.h"
#include <string>

#define sdw(s, var) s->write(&var, sizeof(var))
#define sdr(s, var) s->read(&var, sizeof(var))
enum {
	RFXEV_WCHAT_SENT = 1,
	RFXEV_WCHAT_RECV,
	RFXEV_PRIV_SENT,
	RFXEV_PRIV_RECV,
	RFXEV_SEND_REPLY,
	RFXEV_LOOT_APPEAR,
	RFXEV_LOOT_DISAPPEAR,
	RFXEV_LOOT_PICK_DO,
	RFXEV_LOOT_PICK,
	RFXEV_LAST
};

#define GET_INT16(p) (((uint8_t*)(p))[0] | (((uint8_t*)(p))[1] << 8))
#define GET_INT24(p) (((uint8_t*)(p))[0] | (((uint8_t*)(p))[1] << 8) | (((uint8_t*)(p))[2] << 16))

struct rfx_chat_event : public rfx_event {
	std::string			nick;
	std::string			msg;
	rfx_chat_event(int code, const std::string &nick, const std::string &msg, rf_packet_t *pkt) : rfx_event(code, pkt), nick(nick), msg(msg) {}
};

/*
struct rfx_backpack_event : public rfx_event {
	unsigned			code;
	uint16_t			ground_id;
	rfx_backpack_event(unsigned code, unsigned ground_id, rf_packet_t *pkt) : rfx_event(RFXEV_BACKPACK_LOOKUP, pkt), code(code), ground_id(ground_id) {}
};

struct rfx_pick_event : public rfx_event {
	unsigned			code;
	uint16_t			ground_id;
	unsigned			iid;
	rfx_pick_event(unsigned iid, unsigned code, unsigned ground_id, rf_packet_t *pkt) : rfx_event(RFXEV_BACKPACK_LOOKUP, pkt), code(code), ground_id(ground_id), iid(iid) {}
};
*/

/* this event is generated by rfx_loot module when item appeared/disappeared on the ground.
 * when item disappeared only its gid available */
struct rfx_loot_event : public rfx_event {
	unsigned			code;		/* item hex code */
	unsigned			count;		/* item count */
	uint16_t			gid;		/* ground id */
	rfx_loot_event(unsigned code, unsigned count, uint16_t gid, rf_packet_t *pkt) : rfx_event(RFXEV_LOOT_APPEAR, pkt), code(code), count(count), gid(gid) {}
	rfx_loot_event(uint16_t gid) : rfx_event(RFXEV_LOOT_DISAPPEAR, NULL), code(-1), count(0), gid(gid) {}
};

/* send this event to rfx_loot module to initiate item picking */
struct rfx_pick_do_event : public rfx_event {
	uint16_t			gid;		/* gorund id */
	uint16_t			iid;		/* inventory id */
	unsigned			code;		/* item hex code */
	rfx_pick_do_event(uint16_t gid, uint16_t iid, unsigned code) : rfx_event(RFXEV_LOOT_PICK_DO, NULL), gid(gid), iid(iid), code(code) {}
};

enum {
	PICK_SUCCESS	= 0,
	PICK_FULL		= 3,	/* can't add more items to stack/inventory */
	PICK_TOOFAR		= 6,	/* item is too far away */
	PICK_FAILED		= 127
};

/* this event is send by rfx_loot module when item pick completed */
struct rfx_loot_pick_event : public rfx_event {
	uint16_t			gid;
	uint16_t			iid;
	unsigned			code;
	uint8_t				result;
	/* successful pickup */
	rfx_loot_pick_event(uint16_t gid, uint16_t iid, unsigned code, uint8_t result = PICK_SUCCESS) : rfx_event(RFXEV_LOOT_PICK, NULL), gid(gid), iid(iid), code(code), result(result) {}
	rfx_loot_pick_event(uint8_t result) : rfx_event(RFXEV_LOOT_PICK, NULL), gid(-1), iid(-1), code(-1), result(result) {}
};

void dump_pkt(rf_packet_t *pkt);
uint8_t hex2i(char digit);

/* loot mask */
struct loot_mask {
	uint8_t			mask[8192];

	loot_mask(bool flag) { set(flag); }
	loot_mask(const loot_mask &m) { memcpy(mask, m.mask, sizeof(mask)); }

	void set(bool flag) { memset(mask, flag ? 0xff : 0, sizeof(mask)); }
	bool set(unsigned idx, bool flag);
	bool test(unsigned idx);
	bool operator()(unsigned idx) { return test(idx); }
	loot_mask & operator +=(const unsigned);
	loot_mask & operator -=(const unsigned);
	loot_mask & operator +=(const loot_mask &m);
	loot_mask & operator -=(const loot_mask &m);
	loot_mask & operator =(const loot_mask &m) { memcpy(mask, m.mask, sizeof(mask)); return *this; }
	rfx_state	*save(rfx_state *s) { s->write(mask, sizeof(mask)); return s; }
	bool		restore(rfx_state *s) { return s->read(mask, sizeof(mask)) == sizeof(mask); }
	unsigned	count();

	bool		fsave(const char *name);
	bool		fload(const char *name);
	bool		parse(const std::string &expr);
};

